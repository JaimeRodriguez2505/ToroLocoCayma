campo para descuento global
  descuentoGlobal?: number
}

// Interfaz para respuesta de consulta de cliente
export interface ClienteConsultaResponse {
  // Campos comunes
  tipoDocumento: string
  numeroDocumento: string
  // Campos para RUC
  razonSocial?: string
  estado?: string
  condicion?: string
  direccion?: string
  ubigeo?: string
  distrito?: string
  provincia?: string
  departamento?: string
  // Campos para DNI
  nombre?: string
  nombres?: string
  apellidoPaterno?: string
  apellidoMaterno?: string
}

// Modificar las funciones consultarRuc y consultarDni para usar el backend local

// Funci√≥n para consultar RUC
export const consultarRuc = async (ruc: string): Promise<ClienteConsultaResponse> => {
  const token = localStorage.getItem("token")

  if (!token) {
    throw new Error("No se encontr√≥ token de autenticaci√≥n")
  }
  // Usar la URL del backend principal
  const response = await fetch(`${API_URL}/ruc/${ruc}`, {
    headers: {
      Accept: "application/json",
      Authorization: `Bearer ${token}`,
    },
  })

  if (!response.ok) {
    throw new Error(`Error al consultar RUC: ${response.statusText}`)
  }

  const data = await response.json()
  console.log('Datos RUC recibidos:', data) // Log para depuraci√≥n

  // Adaptar la respuesta al formato esperado por el frontend
  return {
    tipoDocumento: "6", // RUC
    numeroDocumento: ruc,
    razonSocial: data.razon_social,
    direccion: data.direccion,
    estado: data.estado,
    condicion: data.condicion,
  }
}

// Funci√≥n para consultar DNI
export const consultarDni = async (dni: string): Promise<ClienteConsultaResponse> => {
  const token = localStorage.getItem("token")

  if (!token) {
    throw new Error("No se encontr√≥ token de autenticaci√≥n")
  }
  // Usar la URL del backend principal
  const response = await fetch(`${API_URL}/dni/${dni}`, {
    headers: {
      Accept: "application/json",
      Authorization: `Bearer ${token}`,
    },
  })

  if (!response.ok) {
    throw new Error(`Error al consultar DNI: ${response.statusText}`)
  }

  const data = await response.json()
  console.log('Datos DNI recibidos:', data) // Log para depuraci√≥n

  // Adaptar la respuesta al formato esperado por el frontend
  return {
    tipoDocumento: "1", // DNI
    numeroDocumento: dni,
    nombre: data.full_name,
    apellidoPaterno: data.first_last_name,
    apellidoMaterno: data.second_last_name,
    nombres: data.first_name,
  }
}

// Funci√≥n para validar los datos de la factura
export const validateInvoiceData = (data: InvoiceData): boolean => {
  // Verificar que todos los detalles tengan valores v√°lidos
  for (const detail of data.details) {
    if (
      !detail.cantidad ||
      detail.cantidad <= 0 ||
      !detail.mtoValorUnitario ||
      detail.mtoValorUnitario <= 0 ||
      !detail.mtoValorVenta ||
      detail.mtoValorVenta <= 0 ||
      !detail.mtoPrecioUnitario ||
      detail.mtoPrecioUnitario <= 0
    ) {
      return false
    }
  }
  return true
}

// Modificar la funci√≥n sendInvoiceToSunat para mejorar el manejo de errores y agregar logs
export const sendInvoiceToSunat = async (invoiceData: InvoiceData, ventaId?: number): Promise<InvoiceSendResponse> => {
  const token = localStorage.getItem("token")

  if (!token) {
    throw new Error("No se encontr√≥ token de autenticaci√≥n")
  }

  // Validar datos antes de enviar
  if (!validateInvoiceData(invoiceData)) {
    throw new Error(
      "Los datos de la factura contienen valores inv√°lidos. Verifica que todos los precios y cantidades sean mayores a cero.",
    )
  }

  try {
    const requestData = {
      ...invoiceData,
      is_sales_user: true,
    }

    const response = await fetch(`${FACTURADOR_API_URL}/invoices/send`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: token.startsWith("Bearer ") ? token.replace("Bearer ", "") : token,
      },
      body: JSON.stringify(requestData),
    })

    if (!response.ok) {
      const contentType = response.headers.get("content-type") || ""

      if (contentType.includes("text/html")) {
        const htmlText = await response.text()
        let errorMessage = "Error al enviar factura a SUNAT"

        if (htmlText.includes("404 Not Found")) {
          errorMessage = "Servicio de facturaci√≥n no encontrado (404). Verifique que el servicio est√© activo."
        } else if (htmlText.includes("500 Internal Server Error")) {
          errorMessage = "Error interno en el servidor de facturaci√≥n (500)."
        } else if (htmlText.includes("403 Forbidden")) {
          errorMessage = "Acceso denegado al servicio de facturaci√≥n (403)."
        }

        // Actualizar estado como fallido si tenemos ventaId
        if (ventaId) {
          try {
            await updateComprobanteStatus(ventaId, false)
          } catch (updateError) {
            console.error("Error al actualizar estado del comprobante:", updateError)
          }
        }

        throw new Error(errorMessage)
      }

      try {
        const errorData = await response.json()

        // Actualizar estado como fallido si tenemos ventaId
        if (ventaId) {
          try {
            await updateComprobanteStatus(ventaId, false)
          } catch (updateError) {
            console.error("Error al actualizar estado del comprobante:", updateError)
          }
        }

        throw new Error(errorData.message || `Error ${response.status}: ${response.statusText}`)
      } catch (jsonError) {
        // Actualizar estado como fallido si tenemos ventaId
        if (ventaId) {
          try {
            await updateComprobanteStatus(ventaId, false)
          } catch (updateError) {
            console.error("Error al actualizar estado del comprobante:", updateError)
          }
        }

        throw new Error(`Error ${response.status}: ${response.statusText}`)
      }
    }

    const data = await response.json()

    // Actualizar estado seg√∫n el resultado de SUNAT si tenemos ventaId
    if (ventaId) {
      try {
        await updateComprobanteStatus(ventaId, data.sunatResponse?.success || false, data)
      } catch (updateError) {
        console.error("Error al actualizar estado del comprobante:", updateError)
      }
    }

    return data
  } catch (error: any) {
    // Actualizar estado como fallido si tenemos ventaId
    if (ventaId) {
      try {
        await updateComprobanteStatus(ventaId, false)
      } catch (updateError) {
        console.error("Error al actualizar estado del comprobante:", updateError)
      }
    }

    if (error.name === "TypeError" && error.message.includes("Failed to fetch")) {
      throw new Error(
        "No se pudo conectar al servicio de facturaci√≥n. Verifique que el servicio est√© activo y accesible.",
      )
    }

    throw error
  }
}


// Modificar la funci√≥n getInvoicePdf para mejorar el manejo de errores
export const getInvoicePdf = async (invoiceData: InvoiceData): Promise<Blob | string> => {
  const token = localStorage.getItem("token")

  if (!token) {
    throw new Error("No se encontr√≥ token de autenticaci√≥n")
  }

  // Validar datos antes de enviar
  if (!validateInvoiceData(invoiceData)) {
    throw new Error(
      "Los datos de la factura contienen valores inv√°lidos. Verifica que todos los precios y cantidades sean mayores a cero.",
    )
  }

  try {
    // A√±adir un par√°metro para indicar que es una solicitud de un usuario de ventas
    const requestData = {
      ...invoiceData,
      // A√±adir un flag para indicar que podr√≠a ser un usuario de ventas
      is_sales_user: true,
    }

    const response = await fetch(`${FACTURADOR_API_URL}/invoices/pdf`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: token.startsWith("Bearer ") ? token.replace("Bearer ", "") : token,
      },
      body: JSON.stringify(requestData),
    })

    if (!response.ok) {
      const contentType = response.headers.get("content-type") || ""

      // Si la respuesta es HTML, extraer un mensaje m√°s √∫til
      if (contentType.includes("text/html")) {
        const htmlText = await response.text()

        // Intentar extraer un mensaje de error √∫til del HTML
        let errorMessage = "Error al obtener el PDF de la factura"

        // Buscar mensajes de error comunes en el HTML
        if (htmlText.includes("404 Not Found")) {
          errorMessage = "Servicio de generaci√≥n de PDF no encontrado (404). Verifique que el servicio est√© activo."
        } else if (htmlText.includes("500 Internal Server Error")) {
          errorMessage = "Error interno en el servidor al generar PDF (500)."
        }

        throw new Error(errorMessage)
      }      // Intentar parsear como JSON
      try {
        const errorData = await response.json()
        throw new Error(errorData.message || `Error ${response.status}: ${response.statusText}`)
      } catch (jsonError) {
        // Si no es JSON, usar el status code
        throw new Error(`Error ${response.status}: ${response.statusText}`)
      }
    }    // Verificar el tipo de contenido de la respuesta
    const contentType = response.headers.get("content-type")

    if (contentType && contentType.includes("application/pdf")) {
      // Si es un PDF, devolvemos el blob
      return await response.blob()
    } else if (contentType && contentType.includes("application/json")) {
      // Nueva l√≥gica para manejar respuesta JSON con HTML dentro
      const jsonResponse = await response.json()
      
      if (jsonResponse.success && jsonResponse.data && jsonResponse.data.html) {
        const htmlContent = jsonResponse.data.html
        // Asegurarnos de que el HTML tenga los estilos necesarios para impresi√≥n t√©rmica
        const enhancedHtml = enhanceTicketHtml(htmlContent)
        return enhancedHtml
      } else {
        throw new Error(jsonResponse.message || "Error al obtener el HTML de la factura")
      }
    } else if (contentType && contentType.includes("text/html")) {
      // Si es HTML directo, devolvemos el texto HTML (mantener compatibilidad)
      const htmlContent = await response.text()

      // Asegurarnos de que el HTML tenga los estilos necesarios para impresi√≥n t√©rmica
      const enhancedHtml = enhanceTicketHtml(htmlContent)
      return enhancedHtml
    } else {
      // Si no es ni PDF ni HTML ni JSON, intentamos leer como texto para depuraci√≥n
      const text = await response.text()
      return text
    }
  } catch (error: any) {
    // Verificar si el error es de red (CORS, conexi√≥n, etc.)
    if (error.name === "TypeError" && error.message.includes("Failed to fetch")) {
      throw new Error(
        "No se pudo conectar al servicio de generaci√≥n de PDF. Verifique que el servicio est√© activo y accesible.",
      )
    }

    throw error
  }
}

// Funci√≥n para mejorar el HTML del ticket para impresi√≥n t√©rmica
export const enhanceTicketHtml = (html: string): string => {
  // Solo agregar estilos m√≠nimos si no vienen del backend
  if (!html.includes("@page") && !html.includes("@media print")) {
    // Solo estilos b√°sicos para PDF de 80mm, sin interferir con el dise√±o del backend
    const styleTag = `
    <style>
      @page {
        size: 80mm auto;
        margin: 0;
      }
      
      body {
        width: 80mm;
        margin: 0;
        padding: 0;
      }
    </style>
    `

    // Insertar los estilos en el HTML
    html = html.replace("</head>", `${styleTag}</head>`)

    // Si no hay etiqueta head, agregarla
    if (!html.includes("<head>")) {
      html = `<!DOCTYPE html>
<html>
<head>
${styleTag}
</head>
<body>
${html}
</body>
</html>`
    }
  }

  return html
}

// Modificar la funci√≥n prepareInvoiceData para incluir el descuento global
// Buscar la funci√≥n prepareInvoiceData y modificarla:

// Modificar la funci√≥n prepareInvoiceData para incluir el descuento global
export const prepareInvoiceData = (
  sale: any,
  company: any,
  tipoDocumento: string,
  cliente: ClienteConsultaResponse | null,
  series: { facturaActual: number; boletaActual: number },
  nuevoCorrelativo?: number, // Nuevo par√°metro opcional
): InvoiceData => {
  // Usar la fecha de la venta en lugar de la fecha actual
  // La fecha puede venir en formato "2025-07-11 20:57:59", necesitamos convertirla a ISO
  let fechaEmision = "";
  try {
    // Intentar parsear la fecha con diferentes formatos
    let dateTime;
    if (sale.fecha.includes('T')) {
      // Ya est√° en formato ISO
      dateTime = DateTime.fromISO(sale.fecha);
    } else {
      // Formato "YYYY-MM-DD HH:mm:ss", reemplazar espacio con 'T'
      const isoDateString = sale.fecha.replace(' ', 'T');
      dateTime = DateTime.fromISO(isoDateString);
    }
    
    if (dateTime.isValid) {
      fechaEmision = dateTime.setZone("America/Lima").toISO({ suppressMilliseconds: true }) ?? "";
    } else {
      // Si falla, usar la fecha actual como fallback
      console.warn('No se pudo parsear la fecha de la venta:', sale.fecha, 'usando fecha actual');
      fechaEmision = DateTime.now().setZone("America/Lima").toISO({ suppressMilliseconds: true }) ?? "";
    }
  } catch (error) {
    console.error('Error al procesar fecha de venta:', error, 'fecha:', sale.fecha);
    fechaEmision = DateTime.now().setZone("America/Lima").toISO({ suppressMilliseconds: true }) ?? "";
  }
  // Determinar serie y correlativo seg√∫n tipo de documento
  let serie, correlativo

  // Usar la serie de la venta si existe
  if (sale.serie) {
    serie = sale.serie
  } else {
    // Si no tiene serie, usar el formato est√°ndar
    if (tipoDocumento === "01") {
      serie = "F001"
    } else {
      serie = "B001"
    }
  }

  // Usar el correlativo de la venta si existe
  if (sale.correlativo) {
    correlativo = String(sale.correlativo).padStart(8, "0")
  } else if (nuevoCorrelativo) {
    correlativo = String(nuevoCorrelativo).padStart(8, "0")
  } else {
    // Si no tiene correlativo, usar el valor por defecto
    if (tipoDocumento === "01") {
      correlativo = String(series.facturaActual).padStart(8, "0")
    } else {
      correlativo = String(series.boletaActual).padStart(8, "0")
    }
  }

  // Preparar detalles de productos
  const details = sale.items.map((item: any) => {
    // Asegurar que los valores sean n√∫meros v√°lidos mayores que cero
    const precioUnitario = Math.max(0.01, Number.parseFloat(item.precio_unitario_con_igv) || 0.01)
    const cantidad = Math.max(0.01, item.cantidad || 0.01)
    const valorUnitario = Math.max(0.01, precioUnitario / 1.18) // Valor sin IGV
    const valorVenta = Math.max(0.01, valorUnitario * cantidad)
    const igv = Math.max(0.01, valorVenta * 0.18)

    return {
      tipAfeIgv: 10, // Gravado - Operaci√≥n Onerosa
      codProducto: item.producto_id.toString(),
      unidad: "NIU", // Unidad (pieza)
      descripcion: item.nombre || "Producto",
      cantidad: Number(cantidad.toFixed(2)),
      mtoValorUnitario: Number(valorUnitario.toFixed(2)),
      mtoValorVenta: Number(valorVenta.toFixed(2)),
      mtoBaseIgv: Number(valorVenta.toFixed(2)),
      porcentajeIgv: 18,
      igv: Number(igv.toFixed(2)),
      totalImpuestos: Number(igv.toFixed(2)),
      mtoPrecioUnitario: Number(precioUnitario.toFixed(2)),
    }
  })

  // Datos del cliente seg√∫n tipo de documento
  const clientData = {
    tipoDoc: tipoDocumento === "01" ? "6" : "1", // 6 para RUC, 1 para DNI
    numDoc: 0,
    rznSocial: "CLIENTE GENERAL",
  }

  // Priorizar los datos de cliente de la venta
  if (sale.cliente_numero_documento && sale.cliente_nombre) {
    clientData.numDoc = Number(sale.cliente_numero_documento)
    clientData.rznSocial = sale.cliente_nombre
    clientData.tipoDoc = sale.cliente_tipo_documento || (tipoDocumento === "01" ? "6" : "1")
  } else if (cliente) {
    // Si no hay datos en la venta, usar los datos del objeto cliente
    clientData.numDoc = Number(cliente.numeroDocumento)

    if (tipoDocumento === "01") {
      // Factura
      clientData.rznSocial = cliente.razonSocial || "CLIENTE GENERAL"
    } else {
      // Boleta
      // Para boleta, concatenamos nombres y apellidos
      clientData.rznSocial =
        cliente.nombre ||
        `${cliente.apellidoPaterno || ""} ${cliente.apellidoMaterno || ""} ${cliente.nombres || ""}`.trim()
    }
  }

  // Construir objeto de factura
  const invoiceData: InvoiceData = {
    ublVersion: "2.1",
    tipoDoc: tipoDocumento, // "01" Factura o "03" Boleta
    tipoOperacion: "0101", // Venta interna
    serie,
    correlativo,
    fechaEmision,
    formaPago: {
      moneda: "PEN",
      tipo: "Contado", // Podr√≠a ser configurable
    },
    tipoMoneda: "PEN",
    company: {
      ruc: Number(company.ruc),
      razonSocial: company.razon_social || "EMPRESA",
      nombreComercial: company.razon_social || "EMPRESA",
      address: {
        ubigueo: "150101", // Podr√≠a ser configurable
        departamento: "AREQUIPA", // Podr√≠a ser configurable
        provincia: "AREQUIPA", // Podr√≠a ser configurable
        distrito: "AREQUIPA", // Podr√≠a ser configurable
        urbanizacion: "-",
        direccion: company.direccion || "DIRECCI√ìN NO ESPECIFICADA",
        codLocal: "0000",
      },
    },
    client: clientData,
    details,
    // Guardar las series actuales
    serieFactura: "F001",
    correlativoFactura: series.facturaActual,
    serieBoleta: "B001",
    correlativoBoleta: series.boletaActual,  }
  
  // A√±adir descuento global si existe en la venta
  // Verificar m√∫ltiples formas en que puede venir el descuento
  if (sale.es_descuento && sale.descuento) {
    // El monto de descuento en la venta es con IGV; convertir a base (pre-IGV) para SUNAT
    invoiceData.descuentoGlobal = Number(((Number(sale.descuento) || 0) / 1.18).toFixed(2))
  } else if (sale.descuento && Number(sale.descuento) > 0) {
    // Descuento directo sin flag es_descuento (monto con IGV) -> convertir a base
    invoiceData.descuentoGlobal = Number(((Number(sale.descuento) || 0) / 1.18).toFixed(2))
  }

  // Si se proporciona un descuento global directamente, usarlo
  if (sale.descuentoGlobal) {
    // Si llega un descuentoGlobal ya con IGV, convertir a base; si ya es base, idealmente vendr√≠a marcado, pero mantenemos consistencia
    invoiceData.descuentoGlobal = Number(((Number(sale.descuentoGlobal) || 0) / 1.18).toFixed(2))
  }

  return invoiceData
}

// A√±adir la funci√≥n getLastCorrelativo al final del archivo

// Modificar la funci√≥n getLastCorrelativo para convertir el formato del tipo de documento
export const getLastCorrelativo = async (tipoDocumento: string): Promise<number> => {
  try {
    const token = localStorage.getItem("token")
    if (!token) {
      throw new Error("No hay token de autenticaci√≥n")
    }

    // Convertir el formato del tipo de documento de "01"/"03" a "1"/"3" que espera el backend
    const tipoDocBackend = tipoDocumento === "01" ? "1" : "3"

    const response = await fetch(`${API_URL}/ventas/ultimo-correlativo/${tipoDocBackend}`, {
      method: "GET",
      headers: {
        Authorization: token.startsWith("Bearer ") ? token.replace("Bearer ", "") : token,
        "Content-Type": "application/json",
      },
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.message || "Error al obtener el √∫ltimo correlativo")    }

    const data = await response.json()
    return data.correlativo
  } catch (error) {
    return 0 // Valor por defecto en caso de error
  }
}

// Funci√≥n para detectar dispositivos m√≥viles o con poca memoria
export const isMobileOrLowEndDevice = (): boolean => {
  // Detectar dispositivos m√≥viles
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  
  // Detectar dispositivos con poca memoria RAM (si est√° disponible)
  const hasLowMemory = (navigator as any).deviceMemory && (navigator as any).deviceMemory < 4
  
  // Detectar conexi√≥n lenta
  const hasSlowConnection = (navigator as any).connection && 
    ((navigator as any).connection.effectiveType === 'slow-2g' || 
     (navigator as any).connection.effectiveType === '2g' ||
     (navigator as any).connection.effectiveType === '3g')
  
  return isMobile || hasLowMemory || hasSlowConnection
}

// Funci√≥n para limpiar la cach√© y liberar memoria
export const clearMemoryCache = (): void => {
  try {
    // Forzar garbage collection si est√° disponible
    if ((window as any).gc) {
      (window as any).gc()
    }
    
    // Limpiar canvas temporales si existen
    const canvases = document.querySelectorAll('canvas[data-temp="true"]')
    canvases.forEach(canvas => canvas.remove())
    
  } catch (error) {
    console.warn('No se pudo limpiar la cach√© de memoria:', error)
  }
}

// Funci√≥n optimizada para convertir HTML a PDF con soporte para dispositivos m√≥viles

// Funci√≥n simplificada y robusta para convertir HTML a PDF
export const convertHtmlToPdf = async (htmlContent: string): Promise<Blob> => {
  try {
    console.log('üîÑ Iniciando conversi√≥n HTML a PDF...')
    clearMemoryCache()

    const timeoutMs = 60000 // 60 segundos

    // Crear una promesa sin async en el executor para cumplir no-async-promise-executor
    const conversionPromise = new Promise<Blob>((resolve, reject) => {
      (async () => {
        try {
          console.log('üìö Cargando librer√≠as...')
          const [jsPDFModule, html2canvasModule] = await Promise.all([
            import("jspdf"),
            import("html2canvas"),
          ])
          const { jsPDF } = jsPDFModule
          const html2canvas = html2canvasModule.default

          console.log('‚úÖ Librer√≠as cargadas correctamente')
          console.log('üé® Procesando HTML...')

          let processedHtml = htmlContent
          const basicStyles = `
        <style>
          * {
            color: black !important;
            background-color: white !important;
            font-family: 'Courier New', monospace !important;
          }
          body {
            margin: 0;
            padding: 2mm;
            width: 76mm;
            background: white;
          }
        </style>`

          if (processedHtml.includes("<head>")) {
            processedHtml = processedHtml.replace("</head>", basicStyles + "</head>")
          } else {
            processedHtml = `<!DOCTYPE html><html><head>${basicStyles}</head><body>${processedHtml}</body></html>`
          }

          const container = document.createElement("div")
          container.innerHTML = processedHtml
          container.style.position = "absolute"
          container.style.left = "-9999px"
          container.style.top = "0"
          container.style.width = "76mm"
          container.style.backgroundColor = "white"
          container.style.color = "black"
          container.style.fontFamily = "Courier New, monospace"
          container.style.fontSize = "11px"
          container.style.lineHeight = "1.2"
          container.style.padding = "2mm"
          container.style.margin = "0"
          container.style.boxSizing = "border-box"
          container.style.overflow = "visible"
          container.setAttribute('data-temp', 'true')
          document.body.appendChild(container)

          await new Promise(r => setTimeout(r, 200))
          console.log('üì∏ Capturando con html2canvas...')

          const canvasOptions = {
            scale: 2,
            useCORS: true,
            logging: false,
            allowTaint: true,
            backgroundColor: "white",
            width: 76 * 3.78,
            height: container.scrollHeight || container.offsetHeight,
            scrollX: 0,
            scrollY: 0,
            imageTimeout: 10000,
            removeContainer: true,
          }

          console.log('üéØ Renderizando canvas...')
          const canvas = await html2canvas(container, canvasOptions)
          document.body.removeChild(container)

          console.log('üìÑ Creando PDF...')
          const imgData = canvas.toDataURL("image/jpeg", 0.9)
          const pdfWidth = 76
          const pdfHeight = Math.max((canvas.height * pdfWidth) / canvas.width, 50)
          const pdf = new jsPDF({ orientation: "portrait", unit: "mm", format: [pdfWidth, pdfHeight], compress: true })
          pdf.addImage(imgData, "JPEG", 0, 0, pdfWidth, pdfHeight)
          canvas.remove()
          clearMemoryCache()
          console.log('‚úÖ PDF generado correctamente')
          resolve(pdf.output("blob"))
        } catch (error) {
          console.error('‚ùå Error en conversi√≥n:', error)
          reject(new Error("Error en conversi√≥n: " + (((error as Error).message) || "Error desconocido")))
        }
      })()
    })

    console.log(`‚è±Ô∏è Iniciando conversi√≥n con timeout de ${timeoutMs/1000}s...`)
    const result = await Promise.race([
      conversionPromise,
      new Promise<Blob>((_, reject) => setTimeout(() => reject(new Error('Timeout: La conversi√≥n tard√≥ demasiado tiempo')), timeoutMs)),
    ])

    console.log('üéâ Conversi√≥n completada exitosamente')
    return result
  } catch (error) {
    console.error('üí• Error general en convertHtmlToPdf:', error)
    clearMemoryCache()
    const tempContainers = document.querySelectorAll('[data-temp="true"]')
    tempContainers.forEach(container => container.remove())
    throw new Error("Error al convertir HTML a PDF: " + (((error as Error).message) || "Error desconocido"))
  }
}

// Funci√≥n de fallback para generar PDF simple sin html2canvas
export const generateSimplePdf = async (htmlContent: string): Promise<Blob> => {
  try {
    console.log('üîÑ Generando PDF simple como fallback...')
    
    const { jsPDF } = await import("jspdf")
    
    // Crear un PDF simple con el contenido HTML como texto
    const pdf = new jsPDF({
      orientation: "portrait",
      unit: "mm",
      format: [76, 200], // Tama√±o fijo para ticket
      compress: true
    })
    
    // Agregar el contenido HTML como texto simple
    const textContent = htmlContent
      .replace(/<[^>]*>/g, '') // Remover tags HTML
      .replace(/&nbsp;/g, ' ') // Reemplazar espacios no rompibles
      .replace(/&amp;/g, '&') // Reemplazar entidades HTML
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .trim()
    
    // Dividir el texto en l√≠neas
    const lines = textContent.split('\n').filter(line => line.trim())
    
    // Agregar cada l√≠nea al PDF
    let yPosition = 10
    const lineHeight = 5
    const maxWidth = 70
    
    lines.forEach(line => {
      if (yPosition > 190) {
        pdf.addPage()
        yPosition = 10
      }
      
      // Dividir l√≠neas largas
      const wrappedLines = pdf.splitTextToSize(line, maxWidth)
      wrappedLines.forEach((wrappedLine: string) => {
        pdf.text(wrappedLine, 3, yPosition)
        yPosition += lineHeight
      })
    })
    
    console.log('‚úÖ PDF simple generado correctamente')
    return pdf.output("blob")
    
  } catch (error) {
    console.error('‚ùå Error en PDF simple:', error)
    throw new Error("No se pudo generar PDF simple: " + ((error as Error).message || "Error desconocido"))
  }
}

// Agregar una funci√≥n para verificar la disponibilidad del servicio de facturaci√≥n
export const checkFacturadorService = async (): Promise<boolean> => {  try {
    const response = await fetch(`${FACTURADOR_API_URL}/health`, {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
      // Timeout de 5 segundos
      signal: AbortSignal.timeout(5000),
    })

    return response.ok
  } catch (error) {
    return false
  }
}

// Nueva funci√≥n para obtener el PDF del documento exacto enviado a SUNAT
export const getInvoicePdfFromSunatResponse = async (
  invoiceData: InvoiceData, 
  sunatResponse: InvoiceSendResponse
): Promise<Blob | string> => {
  const token = localStorage.getItem("token")

  if (!token) {
    throw new Error("No se encontr√≥ token de autenticaci√≥n")
  }

  try {
    // Enviar los datos originales junto con la respuesta de SUNAT para garantizar consistencia
    const requestData = {
      ...invoiceData,
      is_sales_user: true,
      // Datos del documento ya enviado a SUNAT para garantizar consistencia
      sunat_xml: sunatResponse.xml,
      sunat_hash: sunatResponse.hash,
      sunat_success: sunatResponse.sunatResponse.success,
      sunat_cdr_description: sunatResponse.sunatResponse.cdrDescription,
      // Flag para indicar que queremos el PDF del documento ya enviado
      use_sent_document: true
    }

    const response = await fetch(`${FACTURADOR_API_URL}/invoices/pdf`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: token.startsWith("Bearer ") ? token.replace("Bearer ", "") : token,
      },
      body: JSON.stringify(requestData),
    })

    if (!response.ok) {
      const contentType = response.headers.get("content-type") || ""

      // Si la respuesta es HTML, extraer un mensaje m√°s √∫til
      if (contentType.includes("text/html")) {
        const htmlText = await response.text()

        // Intentar extraer un mensaje de error √∫til del HTML
        let errorMessage = "Error al obtener el PDF del documento enviado a SUNAT"

        // Buscar mensajes de error comunes en el HTML
        if (htmlText.includes("404 Not Found")) {
          errorMessage = "Servicio de generaci√≥n de PDF no encontrado (404). Verifique que el servicio est√© activo."
        } else if (htmlText.includes("500 Internal Server Error")) {
          errorMessage = "Error interno en el servidor al generar PDF del documento enviado (500)."
        }

        throw new Error(errorMessage)
      }

      // Intentar parsear como JSON
      try {
        const errorData = await response.json()
        throw new Error(errorData.message || `Error ${response.status}: ${response.statusText}`)
      } catch (jsonError) {
        // Si no es JSON, usar el status code
        throw new Error(`Error ${response.status}: ${response.statusText}`)
      }
    }

    // Verificar el tipo de contenido de la respuesta
    const contentType = response.headers.get("content-type")

    if (contentType && contentType.includes("application/pdf")) {
      // Si es un PDF, devolvemos el blob
      return await response.blob()
    } else if (contentType && contentType.includes("application/json")) {
      // Nueva l√≥gica para manejar respuesta JSON con HTML dentro
      const jsonResponse = await response.json()
      
      if (jsonResponse.success && jsonResponse.data && jsonResponse.data.html) {
        const htmlContent = jsonResponse.data.html
        // Asegurarnos de que el HTML tenga los estilos necesarios para impresi√≥n t√©rmica
        const enhancedHtml = enhanceTicketHtml(htmlContent)
        return enhancedHtml
      } else {
        throw new Error(jsonResponse.message || "Error al obtener el HTML del documento enviado a SUNAT")
      }
    } else if (contentType && contentType.includes("text/html")) {
      // Si es HTML directo, devolvemos el texto HTML (mantener compatibilidad)
      const htmlContent = await response.text()

      // Asegurarnos de que el HTML tenga los estilos necesarios para impresi√≥n t√©rmica
      const enhancedHtml = enhanceTicketHtml(htmlContent)
      return enhancedHtml
    } else {
      // Si no es ni PDF ni HTML ni JSON, intentamos leer como texto para depuraci√≥n
      const text = await response.text()
      return text
    }
  } catch (error: any) {
    // Verificar si el error es de red (CORS, conexi√≥n, etc.)
    if (error.name === "TypeError" && error.message.includes("Failed to fetch")) {
      throw new Error(
        "No se pudo conectar al servicio de generaci√≥n de PDF del documento enviado. Verifique que el servicio est√© activo y accesible.",
      )
    }

    throw error
  }
}

export const updateComprobanteStatus = async (ventaId: number, success: boolean, sunatData?: any): Promise<void> => {
  const token = localStorage.getItem("token")

  if (!token) {
    throw new Error("No se encontr√≥ token de autenticaci√≥n")
  }

  try {
    const response = await fetch(`${API_URL}/ventas/actualizar-comprobante/${ventaId}`, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        comprobante_emitido: success,
        sunat_data: sunatData || null,
      }),
    })

    if (!response.ok) {
      throw new Error(`Error al actualizar estado del comprobante: ${response.statusText}`)
    }
  } catch (error) {
    console.error("Error al actualizar estado del comprobante:", error)
    throw error
  }
}
